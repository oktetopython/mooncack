// src/lib.rs

// Allow some common clippy lints that are often triggered by generated code.
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::upper_case_acronyms)]
#![allow(clippy::non_camel_case_types)]
#![allow(clippy::non_snake_case)]
#![allow(dead_code)] // Allow dead code for items not yet wrapped or used

// FFI module for raw C bindings
pub mod ffi {
    // This will include the bindings.rs file generated by bindgen in $OUT_DIR
    // The allow attributes are often useful for bindgen-generated code.
    #![allow(non_upper_case_globals)]
    #![allow(non_camel_case_types)]
    #![allow(non_snake_case)]
    #![allow(dead_code)]
    #![allow(improper_ctypes)] // Can be needed if bindgen struggles with complex types
    include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
}

use std::ffi::{CString, CStr};
use std::os::raw::c_char;
use std::ptr;
use std::marker::PhantomData; // For opaque types if we wrap them more strongly
use std::sync::Mutex; // If we were to handle callbacks with shared data in Rust.
use std::fmt;
use std::vec::Vec;
use std::mem::MaybeUninit;


// --- Error Handling ---
#[derive(Debug)]
pub struct BitCrackError(String);

impl fmt::Display for BitCrackError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "BitCrack C API Error: {}", self.0)
    }
}

impl std::error::Error for BitCrackError {}

type Result<T> = std::result::Result<T, BitCrackError>;

fn check_ret(ret_code: ffi::std_os_raw_c_int, context: &str) -> Result<()> {
    if ret_code == 0 {
        Ok(())
    } else {
        Err(BitCrackError(format!("{} (code: {})", context, ret_code)))
    }
}


// --- Safe Wrapper for BitCrackFoundKeyC ---
#[derive(Debug, Clone)]
pub struct FoundKey {
    pub private_key_hex: String,
    pub public_key_hex: String,
    pub address_base58: String,
    pub is_compressed: bool,
}

impl From<&ffi::BitCrackFoundKeyC> for FoundKey {
    fn from(c_key: &ffi::BitCrackFoundKeyC) -> Self {
        unsafe {
            FoundKey {
                private_key_hex: CStr::from_ptr(c_key.private_key_hex.as_ptr() as *const c_char).to_string_lossy().into_owned(),
                public_key_hex: CStr::from_ptr(c_key.public_key_hex.as_ptr() as *const c_char).to_string_lossy().into_owned(),
                address_base58: CStr::from_ptr(c_key.address_base58.as_ptr() as *const c_char).to_string_lossy().into_owned(),
                is_compressed: c_key.is_compressed != 0,
            }
        }
    }
}

// --- Safe Wrapper for BitCrackSession ---
// BitCrackSession from C API is an opaque pointer. We'll wrap it.
// PhantomData can be used if we want to make it !Send and !Sync,
// but for now, simple wrapper. If the C session is thread-safe for these calls, this is fine.
// The C API uses a mutex for the callback, indicating some level of thread-safety consideration.
pub struct BitCrack<'a> {
    session: ffi::BitCrackSession,
    // If methods need to access parts of BitCrack that have a lifetime 'a,
    // (e.g. if CStrings were stored in BitCrack struct and passed to C API)
    // For now, not strictly needed as CStrings are created per-call.
    _phantom: PhantomData<&'a ()>,
}

impl<'a> BitCrack<'a> {
    pub fn new() -> Result<Self> {
        let session = unsafe { ffi::bitcrack_create_session() };
        if session.is_null() {
            Err(BitCrackError("Failed to create BitCrack session (null pointer returned)".to_string()))
        } else {
            Ok(BitCrack { session, _phantom: PhantomData })
        }
    }

    pub fn set_device(&self, device_id: i32, blocks: i32, threads: i32, points_per_thread: i32) -> Result<()> {
        check_ret(
            unsafe { ffi::bitcrack_set_device(self.session, device_id, blocks, threads, points_per_thread) },
            "set_device failed"
        )
    }

    pub fn set_keyspace(&self, start_key_hex: &str, end_key_hex: &str) -> Result<()> {
        let c_start = CString::new(start_key_hex).map_err(|e| BitCrackError(format!("Invalid start_key_hex: {}", e)))?;
        let c_end = CString::new(end_key_hex).map_err(|e| BitCrackError(format!("Invalid end_key_hex: {}", e)))?;
        check_ret(
            unsafe { ffi::bitcrack_set_keyspace(self.session, c_start.as_ptr(), c_end.as_ptr()) },
            "set_keyspace failed"
        )
    }

    pub fn add_targets(&self, addresses: Vec<&str>) -> Result<()> {
        let c_addresses_res: std::result::Result<Vec<CString>, _> = addresses.into_iter()
            .map(CString::new)
            .collect();
        let c_addresses = c_addresses_res.map_err(|e| BitCrackError(format!("Invalid address in targets list: {}", e)))?;

        let c_ptr_addresses: Vec<*const c_char> = c_addresses.iter().map(|s| s.as_ptr()).collect();

        check_ret(
            unsafe { ffi::bitcrack_add_targets(self.session, c_ptr_addresses.as_ptr(), c_ptr_addresses.len() as i32) },
            "add_targets failed"
        )
    }

    pub fn set_compression_mode(&self, mode: i32) -> Result<()> {
        check_ret(
            unsafe { ffi::bitcrack_set_compression_mode(self.session, mode) },
            "set_compression_mode failed"
        )
    }

    pub fn init_search(&self) -> Result<()> {
        check_ret(
            unsafe { ffi::bitcrack_init_search(self.session) },
            "init_search failed"
        )
    }

    pub fn start_search_async(&self) -> Result<()> {
        check_ret(
            unsafe { ffi::bitcrack_start_search_async(self.session) },
            "start_search_async failed"
        )
    }

    pub fn stop_search(&self) { // Assuming C API stop doesn't return errors we need to handle
        unsafe { ffi::bitcrack_stop_search(self.session); }
    }

    pub fn is_search_running(&self) -> bool {
        if self.session.is_null() { return false; }
        (unsafe { ffi::bitcrack_is_search_running(self.session) }) != 0
    }

    pub fn poll_results(&self, max_to_fetch: i32) -> Result<Vec<FoundKey>> {
        if self.session.is_null() { return Err(BitCrackError("Invalid session (null)".to_string())); }
        if max_to_fetch <= 0 { return Err(BitCrackError("max_to_fetch must be positive".to_string())); }

        let mut c_results_buffer: Vec<MaybeUninit<ffi::BitCrackFoundKeyC>> = Vec::with_capacity(max_to_fetch as usize);
        // This is important: Set the vector's length to its capacity
        // so that the C API can write into the allocated but uninitialized memory.
        // Unsafe because we are dealing with uninitialized memory.
        unsafe {
            c_results_buffer.set_len(max_to_fetch as usize);
        }

        let mut num_fetched: i32 = 0;

        check_ret(
            unsafe {
                ffi::bitcrack_poll_results(
                    self.session,
                    c_results_buffer.as_mut_ptr() as *mut ffi::BitCrackFoundKeyC,
                    max_to_fetch,
                    &mut num_fetched
                )
            },
            "poll_results failed"
        )?;

        let mut safe_results = Vec::with_capacity(num_fetched as usize);
        unsafe {
            for i in 0..num_fetched as usize {
                // Assume the C API has properly initialized these items.
                // Create a reference to the (now initialized) BitCrackFoundKeyC struct.
                let c_key_ptr = c_results_buffer[i].as_ptr();
                safe_results.push(FoundKey::from(&*c_key_ptr));
            }
        }
        Ok(safe_results)
    }
}

impl<'a> Drop for BitCrack<'a> {
    fn drop(&mut self) {
        if !self.session.is_null() {
            // If search might be running, good practice to stop it, though C API destroy should handle it.
            if self.is_search_running() {
                 // Consider logging this or making it more explicit if stop_search is not called by user
                self.stop_search();
            }
            unsafe { ffi::bitcrack_destroy_session(self.session); }
            self.session = ptr::null_mut();
        }
    }
}

// Constants for compression modes, mirroring C API (or values from CmdParse.h)
// These values must match what the C API expects.
// PointCompressionType::COMPRESSED = 0
// PointCompressionType::UNCOMPRESSED = 1
// PointCompressionType::BOTH = 2
pub const COMPRESSION_COMPRESSED: i32 = 0;
pub const COMPRESSION_UNCOMPRESSED: i32 = 1;
pub const COMPRESSION_BOTH: i32 = 2;

// TODO: Add tests (e.g., in a tests/ directory or as doc tests)
// These would require a compiled libbitcrack_shared and proper linking.
